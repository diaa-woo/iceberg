[상위 문서로 이동](../README.md)

# reference - 참조자

```cpp
#include <iostream>

int change_val(int *p) {
    *p = 3;

    return 0;
}

int main() {
    int number = 5;

    std::cout << number << std::endl;
    change_val(&number);
    std::cout << number << std::endl;
    return 0;
}
```

함수의 인자를 포인터를 통해 접근하여 지역 함수의 값을 함수에서 참조하여 변경할 수 있는 방법이다. 이처럼 C 언어에서는 어떠한 변수를 가리키고 싶을 땐 반드시 포인터를 사용해야만 했다. 그런데 C++에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공하는데, 이를 바로 **참조자(레퍼런스 - reference)**라고 부른다.

```cpp
#include <iostream>

int main() {
    int a = 3;
    int& another_a = a;

    another_a = 5;
    std::cout << "a : " << a << std::endl;
    std::cout << "another_a : " << another_a << std::endl;

    return 0;
}
```

참조자를 정하는 방법은, 가리키고자 하는 타입 뒤에 `&`를 붙이면 된다. 위처럼 `int`형 변수의 참조자를 만들고 싶을 때에는 `int&`를, `double`의 참조자를 만드려면 `double&`로 하면 된다. 심지어 `int*`와 같은 포인터 타입의 참조자를 만드려면 `int*&`로 쓰면 된다.

위와 같이 선언함으로써 우리는 `another_a`는 `a`의 참조자다! 라고 공표하게 되었다. 이 말인 즉슨 `another_a`는 `a`의 **또다른 이름이라고 컴파일러에게 알려주는 것**이다. 따라서 `another_a`에 어떠한 작업을 수행하든 이는 사실상 `a`에 그 작업을 하는 것과 마찬가지다.

```cpp
another_a = 5;
std::cout << "a : " << a << std::endl;
std::cout << "another_a : " << another_a << std::endl;
```

해당 코드를 실행해보면 a의 값 역시 바뀌었다는 걸 확인할 수 있다.

## reference vs pointer

참조자와 포인터는 상당히 유사한 개념이다. 포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산을 수행할 수 있다. 하지만 차이점 또한 존재하는데, 어떤게 있을까?

### 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 한다.

레퍼런스는 정의시 반드시 누구의 별명인지 명시해야 한다. 즉, 아래와 같이 참조자만 설정하면 오류를 뱉는다.

```cpp
int& another_a;
```

반면 포인터의 경우 전혀 상관이 없다.

```cpp
int* p;
```

### 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.

한 번 어떤 변수의 참조자가 되버린다면, 더이상 다른 변수를 참조할 수 없다.

```cpp
int a = 10;
int &another_a = a;

int b = 3;
another_a = b;      // ?
```

해당 코드를 살펴보면, 마지막에 `another_a = b;` 문장은 그저 `a = b`와 동치이다. 즉, 이미 선언된 참조자에서 한 변수를 참조하라고 선언하면 다른 어떠한 변수든 참조할 수 없게 되버린다.

참고로 `&another_a = b`는 있을 수 없는 일이다.

```cpp
int a = 10;
int *p = &a;    // p는 a를 가리킨다.

int b = 3;
p = &b;         // p는 이제 a를 버리고 b를 가리킨다.
```

반면 포인터는 누구를 가리키는 지 얼마든지 변경할 수 있다.

### 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.

```cpp
int a = 10;
int* p = &a;    // p는 메모리상에서 당당히 8바이트를 차지한다.
```

`p`는 하나의 변수로써 당당히 메모리 공간을 할당 받는다. (32비트 체제에선 4바이트). 그런데 레퍼런스는 다르다.

```cpp
int a = 10;
int &another_a = a;     // another_a가 자리를 차지할 필요가 있을까?
```

만일 내가 컴파일러라면 `another_a`를 위해서 메모리 상에 공간을 할당할 필요가 있을까? 전혀! 왜냐하면 `another_a`가 쓰이는 자리는 모두 `a`로 바꿔치기 하면 되니까!. 따라서 이 경우 레퍼런스는 메모리 상에서 존재하지 않게 된다.

그렇다고 레퍼런스가 아예 메모리 상에 존재하지 않다는 건 아니다. 아래 참조.

## 함수 인자로 레퍼런스 받기

```c++
#include <iostream>

int change_val(int &p) {
    p = 3;

    return 0;
}

int main() {
    int number = 5;

    std::cout << number << std::endl;
    change_val(number);
    std::cout << number << std::endl;
    return 0;
}
```

위 코드는 앞서 포인터를 사용하여 `number`를 `change_val` 안에 전달한 코드를 참조자를 이용해서 바꿔본 것이다.

```cpp
int change_val(int &p) {}
```

아까 `int &p`는 안된다고 설명하였지만, 함수의 매개변수의 경우 전달받은 값을 지역 변수를 선언하여 값을 대입하는 것과 동일하기에 사용 가능하다. 즉, `int &p = number`와 같은 형태가 되기에 가능하다.

해서 위와 같이 참조자 `p`에게 **너는 앞으로 `number`의 새로운 별명이야**라고 알려주게 되는 것이다. 중요한 점은 포인터가 인자일 때와는 다르게 `number` 앞에 `&`를 붙일 필요가 없다는 점이다. 이는 참조자가 정의할 때 그냥 `int& a = b`와 동일하다.

그 후 함수 안에서 매개변수의 값을 변화시킬 때 참조된 다른 지역 함수의 값을 변경해 줄 수 있다.

## 사용 예제들

```cpp
int x;
int& y = x;
int& z = y;
```
참조자의 참조자는 금지되어 있다. 해서 z는 `int&&` 가 아닌, 모두 `x`의 참조자가 되어 `y`, `z` 모두 `x`의 참조자가 된다.

아무래도 처음에 참조자를 접하게 되면은 왜 굳이 포인터로 할 수 있는 것들을 왜 참조자로 해야 하냐고 물을 수 있다. 하지만 참조자를 사용하게 된다면 불필요한 `&`와 `*`가 필요 없기 때문에 코드를 훨씬 간결하게 나타낼 수 있다.

대표적인 예로, C++ 표준 라이브러리 중 표준 입력 함수 `cin`은 다음과 같은 명령줄을 작성해야 한다.

```cpp
std::cin >> user_input;
```

이 문장을 보면 C언어에서 `scanf`를 사용할 때는 변수의 주소를 넘겨주었어야 했다. 하지만 참조자를 이용하여 구질구질하게(ㅋㅋ) `&`를 붙여줄 필요가 없다.

## 상수에 대한 참조자

```cpp
#include <iostream>

int main() {
    int &ref = 4;

    std::cout << ref << std::endl;
}
```

위와 같은 소스를 컴파일러에 집어넣으면 오류를 뱉는다. (C2440) 왜 오류가 발생할까?

상수 값 자체는 변하지 않는 값 **리터럴**이기 때문에 위와 같이 레퍼런스로 참조한다면,

```cpp
ref = 5;
```

처럼 리터럴의 값을 바꾸는 말도 안되는 행위가 가능하게 된다. 따라서 C++ 문법 상 상수 리터럴을 일반적인 레퍼런스가 참조하는 것은 불가능하게 되어있다.

다만, 상수 참조자로 선언한다면 리터럴도 참조할 수 있다.

```cpp
const int &ref = 4;
int a = ref;
```

해당 명령어는 `a = 4;`라는 것으로 처리된다. 

## 레퍼런스의 배열과 배열의 레퍼런스

### 레퍼런스의 배열

먼저 레퍼런스의 배열이 과연 가능한지에 대해 생각해보자. 앞서 말했듯 레퍼런스는 반드시 정의와 함께 초기화를 해주어야 한다. 다만 우리가 아는 배열 선언문으로 작성하면 컴파일 에러를 뱉는다 (C2234)

```cpp
int a, b;
int& arr[2] = {a, b};   // error!
```

실제 레퍼런스를 살펴봐도 레퍼런스의 배열을 **불법(illegal)**이라고 규정했다. (표준안 8.3.2/4) 언어 차원에서 불가능하다고 아예 못 박아버렸다. 그렇다면 대체 왜 안될까? 그냥 `arr[0]`은 참조자 a가 되도록 하면 안되나..?

그 이유는 C, C++이 배열을 어떻게 선언하는지에 대해 따져보면 나온다. C++은 C와 동일하게 여러 변수들을 근접한 메모리주소에 한번에 다 엮어버린다. 이렇기에 `arr[1]`은 `*(arr + 1)`로 바뀌어 사용할 수 있다.

그런데 **주소값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다** 라는 의미와 같다. 하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지 하지 않는다. 따라서 이런 모순 때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지가 되어있다.

### 배열의 레퍼런스

그렇다고 이게 불가능하다는 건 아니다.

```cpp
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  std::cout << arr[0] << arr[1] << arr[2] << std::endl;
  return 0;
}
```

아래 코드들을 동작시켜보면 `231`이라는 결과가 나온다. 선언 부분을 살펴보면, `ref`가 `arr`를 참조하도록 하였다. 따라서 `ref[0]`부터 `ref[2]`가 각각 `arr[0]`부터 `arr[2]`의 레퍼런스가 된다. 포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해선 반드시 배열의 크기를 명시해야한다.

따라서 `int(&ref[3])`이라면 반드시 크기가 3인 `int`배열의 별명이 되어야 하고, `int(&ref[5])`라면 크기가 5인 `int` 배열의 별명이 되어야 한다.

```cpp
int arr[3][2] = {1, 2, 3, 4, 5, 6};
int (&ref)[3][2] = arr;
```

역시 일차원 배열을 했을 때와 동일하다.

## 레퍼런스를 리턴하는 함수

```cpp
int function() {
    int a = 2;
    return a;
}

int main() {
    int b = function();
    return 0;
}
```

`function`안에 정의된 `a`라는 변수의 값이 `b`에 **복사**되었다. 여기서 주목할 점은 *복사*되었다는 점이다.

`function`이 종료되고 나면 `a`는 메모리에서 사라지게 된다. 따라서 더 이상 `main` 안에서는 `a`를 만날 길이 없다.

### 지역변수의 레퍼런스를 리턴

```cpp
int& function() {
    int a = 2;
    return a;
}

int main() {
    int b = function();
    b = 3;
    return 0;
}
```

만일 컴파일을 한다면 아래와 같은 경고가 나오고(오류는 아님), 나중에는 7170 런타임 오류가 뜬다. 뭐가 문제였을까?

```cpp
int& ref = a;

// 근데 a가 사라진다면?
int b = ref;    // 어?
```

위 명령어는 다음과 같은 의미이다. `function`이 레퍼런스를 리턴하면서 원래 참조하고 있던 변수가 이미 사라져벼렸으므로 오류가 발생하게 된다. 쉽게 말해 본체는 이미 사라졌지만 별명만 남아있는 상황인 것이다.

이와 같은 레퍼런스는 있는데 원래 참조하던 것이 사라진 레퍼런스를 **댕글링 레퍼런스(Dangling Reference)**라고 부른다. *Dangling*이란 단어의 원래 뜻은 약하게 결합대서 **달랑달랑**거리는 것을 뜻하는데, 레퍼런스가 참조해야 할 변수가 사라져서 혼자서 덩그러니 남아 있는 상황과 유사하다고 보면 된다.

**그래서 위처럼 레퍼런스를 리턴하는 함수에서 지역 변수의 레퍼런스를 리턴하지 않도록 조심해야한다!!!**

### 외부 변수의 레퍼런스를 리턴

```cpp
int& function(int& a) {
    a = 5;
    return a;
}

int main() {
    int b = 2;
    int c = function(b);
    return 0;
}
```

이 `function` 역시 레퍼런스를 리턴하고 있다. 하지만 아까와의 차이점은 **인자로 받은 레퍼런스를 그대로 리턴**하고 있는 것이다.

`function(b)`를 실행한 시점에서 `a`는 `main`의 `b`를 참조하고 있다. 따라서 `function`이 리턴한 참조자는 **아직 살아있는 변수인 `b`를 계속 참조하고 있다.**

해서 `int c = function(b);` 문장은 그냥 `c`에 현재의 `b`의 값인 5를 대입하는 것과 동일한 문장이 된다.

그렇다면 이렇게 참조자를 리턴하는 경우의 장점은 무엇일까? C언어에서 엄청나케 큰 구조체가 있을 때 해당 구조체 변수를 그냥 리턴하면 전체 복사가 발생해야 해서 시간이 오래 걸리지만, 해당 구조체를 가리키는 포인터를 리턴한다면 그냥 포인터 주소 한 번 복사로 매우 빠르게 끝난다.

마찬가지로 레퍼런스를 리턴하게 된다면 **레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한 번의 주소 값 복사로 전달이 끝나게 된다.**

### 참조자가 아닌 값을 리턴하는 함수를 참조자로 받기

```cpp
int function() {
    int a = 5;
    return a;
}

int main() {
    int& c = function();
    return 0;
}
```

컴파일을 한다면 *상수가 아닌 레퍼런스가 `function` 함수의 리턴값을 참조할 수 없다*는 컴파일 에러가 난다.

왜 `c`는 `function`의 리턴값을 참조할 수 없는 것일까? 이는 아까 전 상황과 마찬가지로 함수의 리턴값을 해당 문장이 끝난 후 바로 사라지는 값이기 때문에 참조자를 만들게 되면 바로 다음에 댕글링 레퍼런스가 되기 때문이다. 

```cpp
int& c = function();
c = 2;
```

따라서 만약 위와 같은 작업을 하게 된다면 앞서 보았던 런타임 오류를 보게 된다.

**하지만 C++에서 매우 중요한 예외 규칙이 있다.**

```cpp
#include <iostream>

int function() {
    int a = 5;
    return a;
}

int main() {
    const int& c = function();
    std::cout << "c : " << c <<std::endl;
    return 0;
}
```

이번에도 역시 `function()`의 리턴값을 참조자로 받았다. 그런데, 이 `const` 참조자로 받았더니 문제없이 컴파일 된다. 그 후 출력도 잘 되고 말이다.

원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 정상이다. 따라서 기존에 `int&`로 받았을 때에는 컴파일 자체가 안되었었다. 하지만 예외적으로 **상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장된다.** 그리고 연장되는 기간은 레퍼런스가 사라질 때 까지이다.

### 정리

| |함수에서 값 리턴(`int f()`)|함수에서 참조자 리턴(`int& f()`)|
|-|-----------------------|------------------|
|값 타입으로 받음(`int a = f()`)|값 복사됨|값 복사됨. 다만 **지역 변수의 레퍼런스를 리턴하지 않도록 주의**|
|참조자 타입으로 받음(`int& a = f()`)|컴파일 오류|가능. 다만 마찬가지로 **지역 변수의 레퍼런스를 리턴하지 않도록 주의**|
|상수 참조자 타입으로 받음(`const int& a = f()`)|가능|가능. 다만 마찬가지로 **지역 변수의 레퍼런스를 리턴하지 않도록 주의**|
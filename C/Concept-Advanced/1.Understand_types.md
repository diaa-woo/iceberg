# 타입의 이해

## C언어의 기본 타입

<p></p>
C언어의 4가지 기본 타입

- 정수 타입: char와 int(word 단위), 실수 타입: float와 double
- short, long, unsigned, register, volatile 등은 한정자(no type)

## 정수의 내부구조

<p></p>
char: 1byte의 정수를 저장하는 타입

```C
    int main() 
    {
        char ch = 250;
        printf("%d\n", ch);   //print: 1111 1010  : -6
    }
```

<p></p>
-1의 S승은 부호비트가 1이면 -1의 1승이므로 음수로 해석되고 부호비트가 0이면 -1의 0승이 되어 양수로 해석된다. <b>이를 통해서 제어문을 사용하지 않고 음수를 구할 수 있다!</b>

## 정수의 감산 동작

<p></p>

정수의 감산기는 바로 앞의 가중치에서 값을 빌려오는 빌림수 연산을 수행한다.<br>
<p>예시: 5-2 = 3</p>
00000101 -> 00000021<br>
-00000010<br>
=00000011<br><br>

<p>정수의 감산 동작 특징</p>

- 정수의 감산 연산시 바로 앞자리에 빌려오는 수가 없다면 빌림수를 빌려오기 위해 계속 앞으로 검색을 수행
- 이때문에 많은 CPU의 GATE가 필요하며, 속도가 느려짐!

### 감산의 기술

<p></p>

- 빼기(5-3)는 감산기를 써야 하나 음수의 덧셈(5+(-3))ㅡ로 해석되면 가산기만으로도 뺄셈이 가능하다.
- 이 연산이 가능하게 하려면 음수를 표현할 수 있어야 한다.(MSB의 표현 유무)
w
부호와 절대값 방식<br>

최상위 비트를 부호 비트로 놓고 나머지 7bit에는 절대값을 저장하는 방식<br>
 00000101 : 5<br>
+10000011 :-3<br>
=10001000 : 5 + (-3) = -8

### 부호와 절대값 방식

<p></p>
부호와 절대값 방식의 문제점 :<br>
부호와 절대값 방식은 음수를 표현하는 것은 가능하나, 부호 잇는 정수를 계산에 이용하면 가산기가 작동하기 때문에 잘못된 계산을 수행한다.<br><br>

이에 대한 개선점: 정수에서 부호를 표시 할 수 있으며 가산기 만으로 빼기가 가능해야 한다.<br><br>

__부호와 1의 보수 절대값 방식__

- 양의 정수 전체를 반전시켜서 1의 보수를 취한다.
- 이때 최상위 비트는 부호비트로 동작한다.

ex)<br>
00000101 : 5, 11111100: -3 <br><br>

문제점   
- 더하기 만으로 빼기가 되나 한번의 연산으로는 절대값이 1 더 적게 계산된다.(10진수에서도 동일하다)
- 두번의 연산으로 속도가 느리다
- 메모리를 낭비한다. (+0과 -0을 표시하기 때문)
  - `00000000` : **+0** -> 모든 비트가 0이면 +0이다.
  - `11111111` : **-0** -> 모든 비트가 1이면 -0이다.

__부호와 2의 절대값 방식__

해결책
- n진수의 **음수**는 n-1의 보수가 아니라 n의 보수를 사용하라

ex)   
`00000101` : 5   
`11111011` + `1` -> `11111101` : 3 에서 음수는 n의 보수를 사용하므로 기존 1의 보수에서 +1을 해줌   
= `00000010` : 2

**주의사항**
2의 보수를 사용하면 한번의 연산만으로는 뺄셈의 결과와 같다.   
**이때 carry(올림수)는 무시한다!**. 위 연산은 10진수에서도 동일하다.

장점
- 메모리 낭비의 문제점을 해결해준다.
- 2의 보수는 0을 양수(+0)만 표시해주고, 음수는 -1부터 시작한다. -> 굳이 +-0을 구분해주지 않아도 된다!
  - `00000000` : +0
  - `11111111` : -1

### 2의 보수 변환의 실제 동작
- 2의 보수 연산
  - 전체 비트를 반전한 후, 1을 더한다.
  - 다만 이런 연산은 1의 보수를 구하는 것보다 속도가 느리다
- 최적화하는 방법(ex: 8)
  - 오른쪽 비트부터 스캔하여, 최초 1을 만날 때까지 바이패스한다.
    - `00001000` -> 1까지 쭉 도달
  - 처음 만나는 1을 놔두고, 그 이후 비트는 반전한다.
    - `11111000` -> 그 지점에서 나머지 비트들을 전부 반전한다.

실제로, Windows 프로그래머 계산기도 2의 보수형태의 연산을 진행하고 있다.


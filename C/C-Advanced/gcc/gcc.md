# gcc 

원래는 __GNU C Compiler__ 를 의미했지만 199년부터는 __GNU Compiler Collection__ 을 의미한다.

## GCC 컴파일러 프로그램들 && 실행 과정

### 프로그램들

- `cpp`: 전처리기
- `cc1`: 컴파일러
- `as`: 어셈블러
- `ld`: 링커

### 실행 과정

1. 전처리 단계(i)

일반 C 소스 파일에 gcc를 동작시키면 가장 먼저 전처리기인 `cpp`가 동작한다. `cpp`는 소스 파일의 `#include`와 `#define`과 같은 #으로 시작되는 전처리기 부분을 처리한다. 즉, 필요한 헤더파일을 삽입하고 실행 문장의 매크로를 상수로 변환한다. 소스파일이 전처리기를 지나면 .i 파일이 생성되는데, 이 파일은 디스크에 저장되지 않는다.

.i 파일을 열어보면 코드가 상당히 많은데, 이는 우리가 포함시켰던 모든 헤더 파일의 내용들을 전부 파일 하나에 집어넣기 때문이다.

2. 컴파일 단계(s)

컴파일러가 전처리된 파일로부터 어셈블리어로 된 확장자 .s 파일을 생성한다. 컴파일 후 바로 다음 단계인 어셈블 단계를 실행하기에 이 파일또한 디스크에 저장되지 않는다.

3. 어셈블 단계(o)

위에서 컴파일 시킨 후 만든 어셈블리 파일을 기계가 직접 이해할 수 있는 기계어로 된 오브젝트 파일, .o 파일을 생성해낸다.

이 파일부터는 직접 내용을 열람하기 어려우며, OS, CPU마다 그 내용이 다르다.

4. 링크 단계

오브젝트 파일은 printf, scanf와 같은 라이브러리 함수에 해당하는 코드가 없기 때문에 바로 실행할 수 없다. 또한 여러 파일로 이루어진 프로그램의 경우에도 파일 간의 연결이 이루어지지 않아 실행될 수 없는데, 이러한 라이브러리 함수와 오브젝트 파일들을 **연결**해 실행 파일을 생성하는 단계가 링크 단계이다.

이 이후에는 우리가 직접 실행할 수 있는 실행파일(.exe, .out 등등)이 나온다.

### 파일 확장자에 따른 처리 방법

gcc는 파일 확장자에 따라 다양한 처리 방법을 달리하는데, 대표적으로 .c인 파일인 경우 gcc로 전처리기, 컴파일, 어셈블, 링크 과정을 거친 후에 실행 파일이 나온다. 그리고 이 과정은 파일의 형태에 따라 다 다른 과정을 거친다.

|확장자|종류|처리방법|
|:---|:-----|:-----|
|.c|C 소스 파일|gcc로 전처리, 컴파일, 어셈블, 링크|
|.C .CC|C++ 소스 파일|gcc로 전처리, 컴파일, 어셈블, 링크|
|.i|전처리된 C 파일|gcc로 컴파일, 어셈블, 링크|
|.ii|전처리된 C++ 파일|g++로 컴파일, 어셈블, 링크|
|.s|어셈블리어로 된 파일|어셈블, 링크|
|.S|어셈블리어로 된 파일|전처리, 어셈블, 링크|
|.o|오브젝트 파일|링크|
|.a .so|컴파일된 라이브러리 파일|링크|

위 표를 살펴보면 gcc는 C뿐만 아니라 순수 어셈블리어 코드 및 라이브러리 파일또한 실행파일로 만들어주는 역할을 해줄 수 있다고 볼 수 있다.(이래서 공부하라는거구만)

## gcc 실행

gcc를 이용해 컴파일하는 방법은 다음과 같다:

```sh
$ gcc 소스파일 이름
```

gcc를 이용해 컴파일에 성공하면 .out이라는 파일이 생성된 것을 확인할 수 있는데, 여기서 그냥 명령어로 a.out을 사용할순 없다. 왜냐하면 a.out 파일이 들어있는 디렉토리는 path로 설정되어 있지 않기 때문에, 단순히 a.out만 친다고 파일을 실행할 수 없다. 따라서 다음과 같이 입력해야 한다.

```sh
$ ./a.out
```

## gcc 옵션

|옵션|의미|
|:---|:---|
|-E|전처리만 실행하고 컴파일을 중단한다.|
|-c|소스 파일을 컴파일하고 오브젝트 파일을 만드는데, 이때 링크는 수행하지 않는다.|
|-o|바이너리 형식의 출력 파일 이름을 지정하는데, 지정하지 않으면 a.out이라는 기본 이름이 적용된다.|
|-I|헤더 파일을 검색하는 디렉토리 목록을 추가한다.|
|-L|라이브러리 파일을 검색하는 디렉토리 목록을 추가한다.|
|-l|라이브러리 파일을 컴파일할 때 링크시켜 준다.|
|-g|바이너리 파일에 표준 디버깅 정보를 포함시킨다.|
|-ggdb|바이너리 파일에 GNU 디버거인 gdb만이 이해할 수 있는 많은 디버깅 정보를 포함시킨다.|
|-O|컴파일 코드를 최적화시킨다.|
|-ON|최적화 N 단계를 지정한다.|
|-DFOO=RAR|명령라인에서 BAR의 값을 가지는 FOO라는 선행 처리기 매크로를 정의한다.|
|-static|정적 라이브러리에 링크한다.|
|-ansi|표준과 충돌하는 GNU 확장안을 취소하며, ANSI/ISO C 표준을 지원한다. 이 옵션은 ANSI 호환 코드를 보장하지 않는다.|
|-traditional|과거 스타일의 함수 정의 형식과 전통적인 K&R(Kernighan and Ritchie) C언어 형식을 지원한다.(요즘 쓰긴 한가?)|
|-MM|make 호환의 의존성 목록을 출력한다.|
|-V|컴파일의 각 단계에서 사용되는 명령어를 보여준다.|

### 자주 쓰이는 옵션

**-o 옵션**

C 소스파일을 컴파일 할 때 생성되는 출력 파일 이름을 지정하는 옵션이다. 실행파일 이름을 내맘대로 지정할 수 있는 점이 큰 핵심이다.

```sh
# -o 옵션
# gcc -o 출력파일이름 소스파일이름

gcc -o file file.c
gcc file.c -o file
```

이렇게 되면 file.c의 실행파일명은 file로 저장이 된다. 이 옵션은 필수로 넣어줘야 하는게, 실행파일의 구분을 확실하게 둘 수 있으며 옵션 미지정시 생성되는 a.out파일은 계속해서 덮어씌워지기 때문이다.(소스코드가 많아질수록 할때마다 컴파일해야함...ㅎ)

**-E 옵션**

컴파일의 첫 단계인 전처리까지만 실행한 결과를 화면에 출력한다.

```sh
# gcc -E 소스파일이름

$ gcc -E file.c # 저장 X, 바로 콘솔에 출력함
$ gcc -E file.c -o file.i # 저장 O
```

기본 전처리 파일은 디스크에 저장되지 않기 때문에 저장하고 싶다면 -o 옵션을 붙여줘야 한다.

**-c 옵션**

-c 옵션은 전처리, 컴파일, 어셈블까지 실행하여 오브젝트 파일을 생성한다.

```sh
# -c 옵션
# gcc -c 소스파일이름

gcc -c file.c # file.o 생성
gcc file.o # 실행파일 생성, a.out 출력
gcc file.o -o file # 이러면 file 출력
```

-c 옵션은 언제 쓰이는 걸까? 이 옵션은 하나의 프로그램을 여러 파일로 분리해 작성한 다음, 함께 컴파일하는 **분리 컴파일**시 많이 사용된다고 한다. 예를 들어 `main.c`와 `hi.c` 두 개의 소스로 구성된 프로그램을 살펴보자.

```c
//main.c
extern void hi();

main() {
    hi();
}
```

```c
//hi.c
#include <stdio.h>

void hi() {
    printf("Hi\n");
}
```

이 둘을 함께 컴파일 하는 방법은 다음과 같으며, 이를 **분리 컴파일**이라고 한다.

```sh
gcc main.c hi.c -o test
./test
```

만약 다음과 같이 파일별로 따로따로 컴파일을 하면 오류가 발생하는데, `main.c` 오류는 호출하는 함수 `hi`라는 함수가 정의되지 않았기 때문이고, `hi.c` 파일에 대한 오류는 `main`함수가 없기 때문이다.

```sh
gcc main.c -o test #error
gcc hi.c -o test #error
```

그러나 이 옵션을 사용한다면 각 파일별로 오브젝트 파일을 만들고, 나중에 링크를 시켜줄 수 있다.

```sh
gcc -c main.c
gcc -c hi.c
gcc main.o hi.o -o test
```

이런식으로 분리 컴파일을 하게 되면 만일 hi.c 파일이 수정되면 main.c와 hi.c를 모두 컴파일할 필요 없이 **hi.c파일에 대한 오브젝트 파일만을 생성하고 링크하면 원하는 실행파일이 생성된다.**

```c
gcc -c hi.c
gcc main.o hi.o -o test
```

지금 당장은 파일 2개만 써서 별로일 수 있지만, 파일이 엄청 많게 쓴 뒤 분리 컴파일 할 때는 다음과 같이 따로따로 해주는게 훨씬 효과적일듯 하다!

__-I 옵션__

-I 옵션은 C소스가 표준 디렉토리가 아닌 위치에 있는 헤더 파일을 가질 때 그 디렉토리 위치를 지정해준다.

